# leetcode-golang

```go
package main

import "fmt"

func main() {
  fmt.Println("Hello, leetcode")
}
```

# 提交总览
| 编号 | 题目 | 解法 | 题目难度 | 提交次数| 重刷次数 |
| --- | --- | --- | --- | --- | --- |
|1|[#1 两数之和](https://leetcode.cn/problems/two-sum)|[1.两数之和.go](leetcode/lc1/1.两数之和.go)|EASY|2|**2**|
|2|[#3 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters)|[3.无重复字符的最长子串.go](leetcode/lc3/3.无重复字符的最长子串.go)|MEDIUM|1|1|
|3|[#5 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring)|[5.最长回文子串.go](leetcode/lc5/5.最长回文子串.go)|MEDIUM|1|1|
|4|[#7 整数反转](https://leetcode.cn/problems/reverse-integer)||MEDIUM|3|1|
|5|[#10 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching)|[10.正则表达式匹配.go](leetcode/lc10/10.正则表达式匹配.go)|HARD|2|1|
|6|[#13 罗马数字转整数](https://leetcode.cn/problems/roman-to-integer)|[13.罗马数字转整数.go](leetcode/lc13/13.罗马数字转整数.go)|EASY|1|1|
|7|[#19 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list)|[19.删除链表的倒数第-n-个结点.go](leetcode/lc19/19.删除链表的倒数第-n-个结点.go)|MEDIUM|11|1|
|8|[#20 有效的括号](https://leetcode.cn/problems/valid-parentheses)|[20.有效的括号.go](leetcode/lc20/20.有效的括号.go)|EASY|2|1|
|9|[#21 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists)|[21.合并两个有序链表.go](leetcode/lc21/21.合并两个有序链表.go)|EASY|4|1|
|10|[#22 括号生成](https://leetcode.cn/problems/generate-parentheses)|[22.括号生成.go](leetcode/lc22/22.括号生成.go)|MEDIUM|1|1|
|11|[#23 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists)|[23.合并k个升序链表.go](leetcode/lc23/23.合并k个升序链表.go)|HARD|2|1|
|12|[#25 K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group)|[25.k-个一组翻转链表.go](leetcode/lc25/25.k-个一组翻转链表.go)|HARD|1|1|
|13|[#26 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array)|[26.删除有序数组中的重复项.go](leetcode/lc26/26.删除有序数组中的重复项.go)|EASY|4|1|
|14|[#27 移除元素](https://leetcode.cn/problems/remove-element)|[27.移除元素.go](leetcode/lc27/27.移除元素.go)|EASY|1|1|
|15|[#28 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string)|[28.找出字符串中第一个匹配项的下标.go](leetcode/lc28/28.找出字符串中第一个匹配项的下标.go)|MEDIUM|5|**2**|
|16|[#34 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array)|[34.在排序数组中查找元素的第一个和最后一个位置.go](leetcode/lc34/34.在排序数组中查找元素的第一个和最后一个位置.go)|MEDIUM|2|1|
|17|[#37 解数独](https://leetcode.cn/problems/sudoku-solver)|[37.解数独.go](leetcode/lc37/37.解数独.go)|HARD|1|1|
|18|[#39 组合总和](https://leetcode.cn/problems/combination-sum)|[39.组合总和.go](leetcode/lc39/39.组合总和.go)|MEDIUM|3|1|
|19|[#40 组合总和 II](https://leetcode.cn/problems/combination-sum-ii)|[40.组合总和-ii.go](leetcode/lc40/40.组合总和-ii.go)|MEDIUM|1|1|
|20|[#45 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii)|[45.跳跃游戏-ii.go](leetcode/lc45/45.跳跃游戏-ii.go)|MEDIUM|4|1|
|21|[#46 全排列](https://leetcode.cn/problems/permutations)|[46.全排列.go](leetcode/lc46/46.全排列.go)|MEDIUM|1|1|
|22|[#47 全排列 II](https://leetcode.cn/problems/permutations-ii)|[47.全排列-ii.go](leetcode/lc47/47.全排列-ii.go)|MEDIUM|4|1|
|23|[#48 旋转图像](https://leetcode.cn/problems/rotate-image)|[48.旋转图像.go](leetcode/lc48/48.旋转图像.go)|MEDIUM|1|1|
|24|[#51 N 皇后](https://leetcode.cn/problems/n-queens)|[51.n-皇后.go](leetcode/lc51/51.n-皇后.go)|HARD|3|1|
|25|[#53 最大子数组和](https://leetcode.cn/problems/maximum-subarray)|[53.最大子数组和.go](leetcode/lc53/53.最大子数组和.go)|MEDIUM|3|**2**|
|26|[#54 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix)|[54.螺旋矩阵.go](leetcode/lc54/54.螺旋矩阵.go)|MEDIUM|3|1|
|27|[#55 跳跃游戏](https://leetcode.cn/problems/jump-game)|[55.跳跃游戏.go](leetcode/lc55/55.跳跃游戏.go)|MEDIUM|1|1|
|28|[#59 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii)|[59.螺旋矩阵-ii.go](leetcode/lc59/59.螺旋矩阵-ii.go)|MEDIUM|5|1|
|29|[#64 最小路径和](https://leetcode.cn/problems/minimum-path-sum)|[64.最小路径和.go](leetcode/lc64/64.最小路径和.go)|MEDIUM|7|**2**|
|30|[#72 编辑距离](https://leetcode.cn/problems/edit-distance)|[72.编辑距离.go](leetcode/lc72/72.编辑距离.go)|HARD|4|1|
|31|[#76 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring)|[76.最小覆盖子串.go](leetcode/lc76/76.最小覆盖子串.go)|HARD|2|1|
|32|[#77 组合](https://leetcode.cn/problems/combinations)|[77.组合.go](leetcode/lc77/77.组合.go)|MEDIUM|2|1|
|33|[#78 子集](https://leetcode.cn/problems/subsets)|[78.子集.go](leetcode/lc78/78.子集.go)|MEDIUM|1|1|
|34|[#83 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list)|[83.删除排序链表中的重复元素.go](leetcode/lc83/83.删除排序链表中的重复元素.go)|EASY|3|1|
|35|[#86 分隔链表](https://leetcode.cn/problems/partition-list)|[86.分隔链表.go](leetcode/lc86/86.分隔链表.go)|MEDIUM|1|1|
|36|[#88 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array)|[88.合并两个有序数组.go](leetcode/lc88/88.合并两个有序数组.go)|EASY|3|1|
|37|[#90 子集 II](https://leetcode.cn/problems/subsets-ii)|[90.子集-ii.go](leetcode/lc90/90.子集-ii.go)|MEDIUM|3|1|
|38|[#92 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii)|[92.反转链表-ii.go](leetcode/lc92/92.反转链表-ii.go)|MEDIUM|1|1|
|39|[#94 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal)|[94.二叉树的中序遍历.go](leetcode/lc94/94.二叉树的中序遍历.go)|EASY|3|1|
|40|[#95 不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii)|[95.不同的二叉搜索树-ii.go](leetcode/lc95/95.不同的二叉搜索树-ii.go)|MEDIUM|3|1|
|41|[#96 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees)|[96.不同的二叉搜索树.go](leetcode/lc96/96.不同的二叉搜索树.go)|MEDIUM|2|1|
|42|[#98 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree)|[98.验证二叉搜索树.go](leetcode/lc98/98.验证二叉搜索树.go)|MEDIUM|2|1|
|43|[#101 对称二叉树](https://leetcode.cn/problems/symmetric-tree)|[101.对称二叉树.go](leetcode/lc101/101.对称二叉树.go)|EASY|3|**2**|
|44|[#104 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree)|[104.二叉树的最大深度.go](leetcode/lc104/104.二叉树的最大深度.go)|EASY|1|1|
|45|[#105 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal)|[105.从前序与中序遍历序列构造二叉树.go](leetcode/lc105/105.从前序与中序遍历序列构造二叉树.go)|MEDIUM|3|1|
|46|[#106 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal)|[106.从中序与后序遍历序列构造二叉树.go](leetcode/lc106/106.从中序与后序遍历序列构造二叉树.go)|MEDIUM|2|1|
|47|[#111 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree)|[111.二叉树的最小深度.go](leetcode/lc111/111.二叉树的最小深度.go)|EASY|3|1|
|48|[#112 路径总和](https://leetcode.cn/problems/path-sum)|[112.路径总和.go](leetcode/lc112/112.路径总和.go)|EASY|1|1|
|49|[#114 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list)|[114.二叉树展开为链表.go](leetcode/lc114/114.二叉树展开为链表.go)|MEDIUM|3|1|
|50|[#116 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node)|[116.填充每个节点的下一个右侧节点指针.go](leetcode/lc116/116.填充每个节点的下一个右侧节点指针.go)|MEDIUM|1|1|
|51|[#121 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock)|[121.买卖股票的最佳时机.go](leetcode/lc121/121.买卖股票的最佳时机.go)|EASY|5|**2**|
|52|[#122 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii)|[122.买卖股票的最佳时机-ii.go](leetcode/lc122/122.买卖股票的最佳时机-ii.go)|MEDIUM|1|1|
|53|[#123 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii)|[123.买卖股票的最佳时机-iii.go](leetcode/lc123/123.买卖股票的最佳时机-iii.go)|HARD|4|1|
|54|[#124 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum)|[124.二叉树中的最大路径和.go](leetcode/lc124/124.二叉树中的最大路径和.go)|HARD|1|1|
|55|[#125 验证回文串](https://leetcode.cn/problems/valid-palindrome)|[125.验证回文串.go](leetcode/lc125/125.验证回文串.go)|EASY|1|1|
|56|[#130 被围绕的区域](https://leetcode.cn/problems/surrounded-regions)|[130.被围绕的区域.go](leetcode/lc130/130.被围绕的区域.go)|MEDIUM|6|1|
|57|[#134 加油站](https://leetcode.cn/problems/gas-station)|[134.加油站.go](leetcode/lc134/134.加油站.go)|MEDIUM|1|1|
|58|[#141 环形链表](https://leetcode.cn/problems/linked-list-cycle)|[141.环形链表.go](leetcode/lc141/141.环形链表.go)|EASY|5|1|
|59|[#142 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii)|[142.环形链表-ii.go](leetcode/lc142/142.环形链表-ii.go)|MEDIUM|1|1|
|60|[#144 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal)|[144.二叉树的前序遍历.go](leetcode/lc144/144.二叉树的前序遍历.go)|EASY|1|1|
|61|[#146 LRU 缓存](https://leetcode.cn/problems/lru-cache)|[146.lru-缓存.go](leetcode/lc146/146.lru-缓存.go)|MEDIUM|2|1|
|62|[#151 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string)|[151.颠倒字符串中的单词.go](leetcode/lc151/151.颠倒字符串中的单词.go)|MEDIUM|2|1|
|63|[#160 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists)|[160.相交链表.go](leetcode/lc160/160.相交链表.go)|EASY|2|1|
|64|[#167 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted)|[167.两数之和-ii-输入有序数组.go](leetcode/lc167/167.两数之和-ii-输入有序数组.go)|MEDIUM|2|1|
|65|[#174 地下城游戏](https://leetcode.cn/problems/dungeon-game)|[174.地下城游戏.go](leetcode/lc174/174.地下城游戏.go)|HARD|2|1|
|66|[#187 重复的DNA序列](https://leetcode.cn/problems/repeated-dna-sequences)|[187.重复的dna序列.go](leetcode/lc187/187.重复的dna序列.go)|MEDIUM|5|1|
|67|[#188 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv)|[188.买卖股票的最佳时机-iv.go](leetcode/lc188/188.买卖股票的最佳时机-iv.go)|HARD|5|1|
|68|[#191 位1的个数](https://leetcode.cn/problems/number-of-1-bits)|[191.位-1-的个数.go](leetcode/lc191/191.位-1-的个数.go)|EASY|1|1|
|69|[#198 打家劫舍](https://leetcode.cn/problems/house-robber)|[198.打家劫舍.go](leetcode/lc198/198.打家劫舍.go)|MEDIUM|2|1|
|70|[#200 岛屿数量](https://leetcode.cn/problems/number-of-islands)|[200.岛屿数量.go](leetcode/lc200/200.岛屿数量.go)|MEDIUM|1|1|
|71|[#206 反转链表](https://leetcode.cn/problems/reverse-linked-list)|[206.反转链表.go](leetcode/lc206/206.反转链表.go)|EASY|3|**2**|
|72|[#213 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii)|[213.打家劫舍-ii.go](leetcode/lc213/213.打家劫舍-ii.go)|MEDIUM|1|1|
|73|[#215 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array)|[215.数组中的第k个最大元素.go](leetcode/lc215/215.数组中的第k个最大元素.go)|MEDIUM|1|1|
|74|[#222 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes)|[222.完全二叉树的节点个数.go](leetcode/lc222/222.完全二叉树的节点个数.go)|MEDIUM|4|1|
|75|[#226 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree)|[226.翻转二叉树.go](leetcode/lc226/226.翻转二叉树.go)|EASY|1|1|
|76|[#230 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst)|[230.二叉搜索树中第k小的元素.go](leetcode/lc230/230.二叉搜索树中第k小的元素.go)|MEDIUM|1|1|
|77|[#232 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks)|[232.用栈实现队列.go](leetcode/lc232/232.用栈实现队列.go)|EASY|1|1|
|78|[#234 回文链表](https://leetcode.cn/problems/palindrome-linked-list)|[234.回文链表.go](leetcode/lc234/234.回文链表.go)|EASY|2|1|
|79|[#235 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree)|[235.二叉搜索树的最近公共祖先.go](leetcode/lc235/235.二叉搜索树的最近公共祖先.go)|MEDIUM|4|1|
|80|[#236 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree)|[236.二叉树的最近公共祖先.go](leetcode/lc236/236.二叉树的最近公共祖先.go)|MEDIUM|1|1|
|81|[#237 删除链表中的节点](https://leetcode.cn/problems/delete-node-in-a-linked-list)|[237.删除链表中的节点.go](leetcode/lc237/237.删除链表中的节点.go)|MEDIUM|2|1|
|82|[#258 各位相加](https://leetcode.cn/problems/add-digits)|[258.各位相加.go](leetcode/lc258/258.各位相加.go)|EASY|2|1|
|83|[#268 丢失的数字](https://leetcode.cn/problems/missing-number)|[268.丢失的数字.go](leetcode/lc268/268.丢失的数字.go)|EASY|2|1|
|84|[#283 移动零](https://leetcode.cn/problems/move-zeroes)|[283.移动零.go](leetcode/lc283/283.移动零.go)|EASY|1|1|
|85|[#297 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree)|[297.二叉树的序列化与反序列化.go](leetcode/lc297/297.二叉树的序列化与反序列化.go)|HARD|10|1|
|86|[#300 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence)|[300.最长递增子序列.go](leetcode/lc300/300.最长递增子序列.go)|MEDIUM|3|**2**|
|87|[#303 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable)|[303.区域和检索-数组不可变.go](leetcode/lc303/303.区域和检索-数组不可变.go)|EASY|2|1|
|88|[#304 二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable)|[304.二维区域和检索-矩阵不可变.go](leetcode/lc304/304.二维区域和检索-矩阵不可变.go)|MEDIUM|1|1|
|89|[#309 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown)|[309.最佳买卖股票时机含冷冻期.go](leetcode/lc309/309.最佳买卖股票时机含冷冻期.go)|MEDIUM|2|1|
|90|[#312 戳气球](https://leetcode.cn/problems/burst-balloons)|[312.戳气球.go](leetcode/lc312/312.戳气球.go)|HARD|2|1|
|91|[#315 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self)|[315.计算右侧小于当前元素的个数.go](leetcode/lc315/315.计算右侧小于当前元素的个数.go)|HARD|1|1|
|92|[#316 去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters)|[316.去除重复字母.go](leetcode/lc316/316.去除重复字母.go)|MEDIUM|4|1|
|93|[#322 零钱兑换](https://leetcode.cn/problems/coin-change)|[322.零钱兑换.go](leetcode/lc322/322.零钱兑换.go)|MEDIUM|15|1|
|94|[#327 区间和的个数](https://leetcode.cn/problems/count-of-range-sum)|[327.区间和的个数.go](leetcode/lc327/327.区间和的个数.go)|HARD|2|1|
|95|[#337 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii)|[337.打家劫舍-iii.go](leetcode/lc337/337.打家劫舍-iii.go)|MEDIUM|5|1|
|96|[#341 扁平化嵌套列表迭代器](https://leetcode.cn/problems/flatten-nested-list-iterator)|[341.扁平化嵌套列表迭代器.go](leetcode/lc341/341.扁平化嵌套列表迭代器.go)|MEDIUM|3|1|
|97|[#344 反转字符串](https://leetcode.cn/problems/reverse-string)|[344.反转字符串.go](leetcode/lc344/344.反转字符串.go)|EASY|1|1|
|98|[#354 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes)|[354.俄罗斯套娃信封问题.go](leetcode/lc354/354.俄罗斯套娃信封问题.go)|HARD|1|1|
|99|[#380 O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1)|[380.o-1-时间插入、删除和获取随机元素.go](leetcode/lc380/380.o-1-时间插入、删除和获取随机元素.go)|MEDIUM|2|1|
|100|[#386 字典序排数](https://leetcode.cn/problems/lexicographical-numbers)||MEDIUM|1|1|
|101|[#387 字符串中的第一个唯一字符](https://leetcode.cn/problems/first-unique-character-in-a-string)|[387.字符串中的第一个唯一字符.go](leetcode/lc387/387.字符串中的第一个唯一字符.go)|EASY|1|1|
|102|[#416 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum)|[416.分割等和子集.go](leetcode/lc416/416.分割等和子集.go)|MEDIUM|1|1|
|103|[#435 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals)|[435.无重叠区间.go](leetcode/lc435/435.无重叠区间.go)|MEDIUM|2|1|
|104|[#438 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string)|[438.找到字符串中所有字母异位词.go](leetcode/lc438/438.找到字符串中所有字母异位词.go)|MEDIUM|2|1|
|105|[#450 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst)|[450.删除二叉搜索树中的节点.go](leetcode/lc450/450.删除二叉搜索树中的节点.go)|MEDIUM|2|1|
|106|[#452 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons)|[452.用最少数量的箭引爆气球.go](leetcode/lc452/452.用最少数量的箭引爆气球.go)|MEDIUM|1|1|
|107|[#460 LFU 缓存](https://leetcode.cn/problems/lfu-cache)|[460.lfu-缓存.go](leetcode/lc460/460.lfu-缓存.go)|HARD|2|1|
|108|[#486 预测赢家](https://leetcode.cn/problems/predict-the-winner)|[486.预测赢家.go](leetcode/lc486/486.预测赢家.go)|MEDIUM|2|1|
|109|[#493 翻转对](https://leetcode.cn/problems/reverse-pairs)|[493.翻转对.go](leetcode/lc493/493.翻转对.go)|HARD|7|1|
|110|[#494 目标和](https://leetcode.cn/problems/target-sum)|[494.目标和.go](leetcode/lc494/494.目标和.go)|MEDIUM|6|1|
|111|[#509 斐波那契数](https://leetcode.cn/problems/fibonacci-number)|[509.斐波那契数.go](leetcode/lc509/509.斐波那契数.go)|EASY|5|1|
|112|[#514 自由之路](https://leetcode.cn/problems/freedom-trail)|[514.自由之路.go](leetcode/lc514/514.自由之路.go)|HARD|2|1|
|113|[#516 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence)|[516.最长回文子序列.go](leetcode/lc516/516.最长回文子序列.go)|MEDIUM|4|1|
|114|[#518 零钱兑换 II](https://leetcode.cn/problems/coin-change-2)|[518.零钱兑换-ii.go](leetcode/lc518/518.零钱兑换-ii.go)|MEDIUM|4|1|
|115|[#528 按权重随机选择](https://leetcode.cn/problems/random-pick-with-weight)|[528.按权重随机选择.go](leetcode/lc528/528.按权重随机选择.go)|MEDIUM|2|1|
|116|[#538 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree)|[538.把二叉搜索树转换为累加树.go](leetcode/lc538/538.把二叉搜索树转换为累加树.go)|MEDIUM|1|1|
|117|[#543 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree)|[543.二叉树的直径.go](leetcode/lc543/543.二叉树的直径.go)|EASY|2|1|
|118|[#567 字符串的排列](https://leetcode.cn/problems/permutation-in-string)|[567.字符串的排列.go](leetcode/lc567/567.字符串的排列.go)|MEDIUM|3|1|
|119|[#583 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings)|[583.两个字符串的删除操作.go](leetcode/lc583/583.两个字符串的删除操作.go)|MEDIUM|2|1|
|120|[#652 寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees)|[652.寻找重复的子树.go](leetcode/lc652/652.寻找重复的子树.go)|MEDIUM|3|1|
|121|[#654 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree)|[654.最大二叉树.go](leetcode/lc654/654.最大二叉树.go)|MEDIUM|2|1|
|122|[#669 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree)|[669.修剪二叉搜索树.go](leetcode/lc669/669.修剪二叉搜索树.go)|MEDIUM|1|1|
|123|[#687 最长同值路径](https://leetcode.cn/problems/longest-univalue-path)||MEDIUM|4|1|
|124|[#695 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island)|[695.岛屿的最大面积.go](leetcode/lc695/695.岛屿的最大面积.go)|MEDIUM|1|1|
|125|[#698 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets)|[698.划分为k个相等的子集.go](leetcode/lc698/698.划分为k个相等的子集.go)|MEDIUM|2|1|
|126|[#700 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree)|[700.二叉搜索树中的搜索.go](leetcode/lc700/700.二叉搜索树中的搜索.go)|EASY|1|1|
|127|[#701 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree)|[701.二叉搜索树中的插入操作.go](leetcode/lc701/701.二叉搜索树中的插入操作.go)|MEDIUM|1|1|
|128|[#704 二分查找](https://leetcode.cn/problems/binary-search)|[704.二分查找.go](leetcode/lc704/704.二分查找.go)|EASY|1|1|
|129|[#710 黑名单中的随机数](https://leetcode.cn/problems/random-pick-with-blacklist)|[710.黑名单中的随机数.go](leetcode/lc710/710.黑名单中的随机数.go)|HARD|2|1|
|130|[#712 两个字符串的最小ASCII删除和](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings)|[712.两个字符串的最小ascii删除和.go](leetcode/lc712/712.两个字符串的最小ascii删除和.go)|MEDIUM|4|1|
|131|[#714 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)|[714.买卖股票的最佳时机含手续费.go](leetcode/lc714/714.买卖股票的最佳时机含手续费.go)|MEDIUM|2|1|
|132|[#752 打开转盘锁](https://leetcode.cn/problems/open-the-lock)|[752.打开转盘锁.go](leetcode/lc752/752.打开转盘锁.go)|MEDIUM|5|1|
|133|[#773 滑动谜题](https://leetcode.cn/problems/sliding-puzzle)|[773.滑动谜题.go](leetcode/lc773/773.滑动谜题.go)|HARD|2|1|
|134|[#787 K 站中转内最便宜的航班](https://leetcode.cn/problems/cheapest-flights-within-k-stops)|[787.k-站中转内最便宜的航班.go](leetcode/lc787/787.k-站中转内最便宜的航班.go)|MEDIUM|3|1|
|135|[#797 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target)|[797.所有可能的路径.go](leetcode/lc797/797.所有可能的路径.go)|MEDIUM|1|1|
|136|[#811 子域名访问计数](https://leetcode.cn/problems/subdomain-visit-count)|[811.子域名访问计数.go](leetcode/lc811/811.子域名访问计数.go)|MEDIUM|1|1|
|137|[#856 括号的分数](https://leetcode.cn/problems/score-of-parentheses)|[856.括号的分数.go](leetcode/lc856/856.括号的分数.go)|MEDIUM|3|1|
|138|[#870 优势洗牌](https://leetcode.cn/problems/advantage-shuffle)|[870.优势洗牌.go](leetcode/lc870/870.优势洗牌.go)|MEDIUM|6|1|
|139|[#876 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list)|[876.链表的中间结点.go](leetcode/lc876/876.链表的中间结点.go)|EASY|2|1|
|140|[#877 石子游戏](https://leetcode.cn/problems/stone-game)|[877.石子游戏.go](leetcode/lc877/877.石子游戏.go)|MEDIUM|1|1|
|141|[#887 鸡蛋掉落](https://leetcode.cn/problems/super-egg-drop)|[887.鸡蛋掉落.go](leetcode/lc887/887.鸡蛋掉落.go)|HARD|5|1|
|142|[#889 根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal)|[889.根据前序和后序遍历构造二叉树.go](leetcode/lc889/889.根据前序和后序遍历构造二叉树.go)|MEDIUM|4|1|
|143|[#912 排序数组](https://leetcode.cn/problems/sort-an-array)|[912.排序数组.go](leetcode/lc912/912.排序数组.go)|MEDIUM|6|**4**|
|144|[#927 三等分](https://leetcode.cn/problems/three-equal-parts)|[927.三等分.go](leetcode/lc927/927.三等分.go)|HARD|1|1|
|145|[#931 下降路径最小和](https://leetcode.cn/problems/minimum-falling-path-sum)|[931.下降路径最小和.go](leetcode/lc931/931.下降路径最小和.go)|MEDIUM|3|1|
|146|[#1020 飞地的数量](https://leetcode.cn/problems/number-of-enclaves)|[1020.飞地的数量.go](leetcode/lc1020/1020.飞地的数量.go)|MEDIUM|3|1|
|147|[#1024 视频拼接](https://leetcode.cn/problems/video-stitching)|[1024.视频拼接.go](leetcode/lc1024/1024.视频拼接.go)|MEDIUM|3|1|
|148|[#1038 从二叉搜索树到更大和树](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree)|[1038.从二叉搜索树到更大和树.go](leetcode/lc1038/1038.从二叉搜索树到更大和树.go)|MEDIUM|1|1|
|149|[#1081 不同字符的最小子序列](https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters)|[1081.不同字符的最小子序列.go](leetcode/lc1081/1081.不同字符的最小子序列.go)|MEDIUM|4|1|
|150|[#1094 拼车](https://leetcode.cn/problems/car-pooling)|[1094.拼车.go](leetcode/lc1094/1094.拼车.go)|MEDIUM|5|1|
|151|[#1109 航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings)|[1109.航班预订统计.go](leetcode/lc1109/1109.航班预订统计.go)|MEDIUM|1|1|
|152|[#1143 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence)|[1143.最长公共子序列.go](leetcode/lc1143/1143.最长公共子序列.go)|MEDIUM|3|1|
|153|[#1254 统计封闭岛屿的数目](https://leetcode.cn/problems/number-of-closed-islands)|[1254.统计封闭岛屿的数目.go](leetcode/lc1254/1254.统计封闭岛屿的数目.go)|MEDIUM|3|1|
|154|[#1312 让字符串成为回文串的最少插入次数](https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome)|[1312.让字符串成为回文串的最少插入次数.go](leetcode/lc1312/1312.让字符串成为回文串的最少插入次数.go)|HARD|6|1|
|155|[#1624 两个相同字符之间的最长子字符串](https://leetcode.cn/problems/largest-substring-between-two-equal-characters)||EASY|2|1|
|156|[#1800 最大升序子数组和](https://leetcode.cn/problems/maximum-ascending-subarray-sum)|[1800.最大升序子数组和.go](leetcode/lc1800/1800.最大升序子数组和.go)|EASY|1|1|
|157|[#1905 统计子岛屿](https://leetcode.cn/problems/count-sub-islands)|[1905.统计子岛屿.go](leetcode/lc1905/1905.统计子岛屿.go)|MEDIUM|1|1|
|158|[#2395 和相等的子数组](https://leetcode.cn/problems/find-subarrays-with-equal-sum)||EASY|4|1|
|159|[#2396 严格回文的数字](https://leetcode.cn/problems/strictly-palindromic-number)||MEDIUM|2|1|
|160|[#2399 检查相同字母间的距离](https://leetcode.cn/problems/check-distances-between-same-letters)||EASY|2|1|
|161|[#2400 恰好移动 k 步到达某一位置的方法数目](https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps)||MEDIUM|5|1|
|162|[#2409 统计共同度过的日子数](https://leetcode.cn/problems/count-days-spent-together)|[2409.统计共同度过的日子数.go](leetcode/lc2409/2409.统计共同度过的日子数.go)|EASY|11|**2**|
|163|[#2410 运动员和训练师的最大匹配数](https://leetcode.cn/problems/maximum-matching-of-players-with-trainers)|[2410.运动员和训练师的最大匹配数.go](leetcode/lc2410/2410.运动员和训练师的最大匹配数.go)|MEDIUM|4|1|
|164|[#2411 按位或最大的最小子数组长度](https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or)|[2411.按位或最大的最小子数组长度.go](leetcode/lc2411/2411.按位或最大的最小子数组长度.go)|MEDIUM|7|1|
|165|[#2412 完成所有交易的初始最少钱数](https://leetcode.cn/problems/minimum-money-required-before-transactions)|[2412.完成所有交易的初始最少钱数.go](leetcode/lc2412/2412.完成所有交易的初始最少钱数.go)|HARD|3|1|
|166|[#2413 最小偶倍数](https://leetcode.cn/problems/smallest-even-multiple)|[2413.最小偶倍数.go](leetcode/lc2413/2413.最小偶倍数.go)|EASY|2|1|
|167|[#2414 最长的字母序连续子字符串的长度](https://leetcode.cn/problems/length-of-the-longest-alphabetical-continuous-substring)|[2414.最长的字母序连续子字符串的长度.go](leetcode/lc2414/2414.最长的字母序连续子字符串的长度.go)|MEDIUM|4|1|
|168|[#2415 反转二叉树的奇数层](https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree)|[2415.反转二叉树的奇数层.go](leetcode/lc2415/2415.反转二叉树的奇数层.go)|MEDIUM|20|1|
|169|[#2416 字符串的前缀分数和](https://leetcode.cn/problems/sum-of-prefix-scores-of-strings)|[2416.字符串的前缀分数和.go](leetcode/lc2416/2416.字符串的前缀分数和.go)|HARD|8|1|

# 文件结构
![Visualization of this repo](./diagram.svg)
# 算法框架

## 前缀和数组

一维数组

```java
class PrefixSum {
    // 前缀和数组
    private int[] prefix;
    
    /* 输入一个数组，构造前缀和 */
    public PrefixSum(int[] nums) {
        prefix = new int[nums.length + 1];
        // 计算 nums 的累加和
        for (int i = 1; i < prefix.length; i++) {
            prefix[i] = prefix[i - 1] + nums[i - 1];
        }
    }

    /* 查询闭区间 [i, j] 的累加和 */
    public int query(int i, int j) {
        return prefix[j + 1] - prefix[i];
    }
}

```

二维数组

```java
class NumMatrix {
    // 定义：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和
    private int[][] preSum;
    
    public NumMatrix(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        if (m == 0 || n == 0) return;
        // 构造前缀和矩阵
        preSum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 计算每个矩阵 [0, 0, i, j] 的元素和
                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1];
            }
        }
    }
    
    // 计算子矩阵 [x1, y1, x2, y2] 的元素和
    public int sumRegion(int x1, int y1, int x2, int y2) {
        // 目标矩阵之和由四个相邻矩阵运算获得
        return preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1];
    }
}
```

## 差分数组
```java
// 差分数组工具类
class Difference {
    // 差分数组
    private int[] diff;
    
    /* 输入一个初始数组，区间操作将在这个数组上进行 */
    public Difference(int[] nums) {
        assert nums.length > 0;
        diff = new int[nums.length];
        // 根据初始数组构造差分数组
        diff[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            diff[i] = nums[i] - nums[i - 1];
        }
    }

    /* 给闭区间 [i, j] 增加 val（可以是负数）*/
    public void increment(int i, int j, int val) {
        diff[i] += val;
        if (j + 1 < diff.length) {
            diff[j + 1] -= val;
        }
    }

    /* 返回结果数组 */
    public int[] result() {
        int[] res = new int[diff.length];
        // 根据差分数组构造结果数组
        res[0] = diff[0];
        for (int i = 1; i < diff.length; i++) {
            res[i] = res[i - 1] + diff[i];
        }
        return res;
    }
}

```

## 滑动窗口
```c++
void slidingWindow(string s) {
    unordered_map<char, int> window;
    
    int left = 0, right = 0;
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 增大窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 缩小窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```

## Rabin-Karp 算法
```java
// Rabin-Karp 指纹字符串查找算法
int rabinKarp(String txt, String pat) {
    // 位数
    int L = pat.length();
    // 进制（只考虑 ASCII 编码）
    int R = 256;
    // 取一个比较大的素数作为求模的除数
    long Q = 1658598167;
    // R^(L - 1) 的结果
    long RL = 1;
    for (int i = 1; i <= L - 1; i++) {
        // 计算过程中不断求模，避免溢出
        RL = (RL * R) % Q;
    }
    // 计算模式串的哈希值，时间 O(L)
    long patHash = 0;
    for (int i = 0; i < pat.length(); i++) {
        patHash = (R * patHash + pat.charAt(i)) % Q;
    }
    
    // 滑动窗口中子字符串的哈希值
    long windowHash = 0;
    
    // 滑动窗口代码框架，时间 O(N)
    int left = 0, right = 0;
    while (right < txt.length()) {
        // 扩大窗口，移入字符
        windowHash = ((R * windowHash) % Q + txt.charAt(right)) % Q;
        right++;

        // 当子串的长度达到要求
        if (right - left == L) {
            // 根据哈希值判断是否匹配模式串
            if (windowHash == patHash) {
                // 当前窗口中的子串哈希值等于模式串的哈希值
                // 还需进一步确认窗口子串是否真的和模式串相同，避免哈希冲突
                if (pat.equals(txt.substring(left, right))) {
                    return left;
                }
            }
            // 缩小窗口，移出字符
            windowHash = (windowHash - (txt.charAt(left) * RL) % Q + Q) % Q;
            // X % Q == (X + Q) % Q 是一个模运算法则
            // 因为 windowHash - (txt[left] * RL) % Q 可能是负数
            // 所以额外再加一个 Q，保证 windowHash 不会是负数

            left++;
        }
    }
    // 没有找到模式串
    return -1;
}
```

## 排序

### 冒泡排序

```go
func sortArray(nums []int) []int {
    // 冒泡排序，比较交换，稳定算法，时间O(n^2), 空间O(1)
	// 每一轮遍历，将该轮最大值放到后面，同时小的往前冒
	// 从而形成后部是有序区
	// compare and swap
	for i:=0;i<len(nums);i++ {
		// 适当剪枝，len()-i到最后的部分都是有序区，避免再排
		for j:=1;j<len(nums)-i;j++ {
			if nums[j-1] > nums[j] {
				nums[j-1], nums[j] = nums[j], nums[j-1]
			}
		}
	}
	return nums
}
```

### 选择排序

```go
func sortArray(nums []int) []int {
	// 选择排序，比较交换，不稳定算法，时间O(n^2)，空间O(1)
	// 每一轮遍历，该轮的最小值前挪，从而形成前面部分是有序区
	// compare and swap
	for i:=0;i<len(nums);i++ {
		// 剪枝前面部分，比较后面部分
		for j:=i+1;j<len(nums);j++ {
			if nums[i] > nums[j] {
				nums[i], nums[j] = nums[j], nums[i]
			}
		}
	}
	return nums
}
```

### 插入排序

```go
func sortArray(nums []int) []int {
	// 插入排序，比较交换，稳定算法，时间O(n^2)，空间O(1)
	// 0->len方向，每轮从后往前比较，相当于找到合适位置，插入进去
	// 数据规模小的时候，或基本有序，效率高
	n := len(nums)
	for i := 1; i < n; i++ {
		tmp := nums[i]
		j := i - 1
		for j >= 0 && nums[j] > tmp { //左边比右边大
			nums[j+1] = nums[j] //右移1位
			j--                 //扫描前一个数
		}
		nums[j+1] = tmp //添加到小于它的数的右边
	}
	return nums
}
```

### 希尔排序

```go
func sortArray(nums []int) []int {
	// 希尔排序，比较交换，不稳定算法，时间O(nlog2n)最坏O(n^2), 空间O(1)
	// 改进插入算法
	// 每一轮按照间隔插入排序，间隔依次减小，最后一次一定是1
	/*
	主要思想：
	设增量序列个数为k，则进行k轮排序。每一轮中，
	按照某个增量将数据分割成较小的若干组，
	每一组内部进行插入排序；各组排序完毕后，
	减小增量，进行下一轮的内部排序。
	*/
	gap := len(nums)/2
	for gap > 0 {
		for i:=gap;i<len(nums);i++ {
			j := i
			for j-gap >= 0 && nums[j-gap] > nums[j] {
				nums[j-gap], nums[j] = nums[j], nums[j-gap]
				j -= gap
			}
		}
		gap /= 2
	}
	return nums
}
```

### 归并排序

```go
// 递归实现归并算法
func sortArray(nums []int) []int {
	// 归并排序，基于比较，稳定算法，时间O(nlogn)，空间O(logn) | O(n)
	// 基于递归的归并-自上而下的合并，另有非递归法的归并(自下而上的合并)
	// 都需要开辟一个大小为n的数组中转
	// 将数组分为左右两部分，递归左右两块，最后合并，即归并
	// 如在一个合并中，将两块部分的元素，遍历取较小值填入结果集
	// 类似两个有序链表的合并，每次两两合并相邻的两个有序序列，直到整个序列有序
	n := len(nums)
	temp := make([]int, n)

	var merge func([]int, int, int, int)
	merge = func(nums []int, lo, mid, hi int) {
		for i := lo; i <= hi; i++ {
			temp[i] = nums[i]
		}
		i, j := lo, mid+1
		for p := lo; p <= hi; p++ {
			if i == mid+1 {
				// 左半边数组已全部被合并
				nums[p] = temp[j]
				j++
			} else if j == hi+1 {
				// 右半边数组已全部被合并
				nums[p] = temp[i]
				i++
			} else if temp[i] > temp[j] {
				nums[p] = temp[j]
				j++
			} else {
				nums[p] = temp[i]
				i++
			}
		}
	}

	var sort func([]int, int, int)
	sort = func(nums []int, lo, hi int) {
		if lo == hi {
			// 单个元素不用排序
			return
		}
		mid := lo + (hi-lo)/2
		sort(nums, lo, mid)
		sort(nums, mid+1, hi)
		merge(nums, lo, mid, hi)
	}

	sort(nums, 0, n-1)	
	return nums
}

// 非递归实现归并算法
func sortArray(nums []int) []int {
	// 归并排序-非递归实现，利用变量，自下而上的方式合并
	// 时间O(nlogn)，空间O(n)
	if len(nums) <= 1 {return nums}
	merge := func(left, right []int) []int {
		res := make([]int, len(left)+len(right))
		var l,r,i int
		// 通过遍历完成比较填入res中
		for l < len(left) && r < len(right) {
			if left[l] <= right[r] {
				res[i] = left[l]
				l++
			} else {
				res[i] = right[r]
				r++
			}
			i++
		}
		// 如果left或者right还有剩余元素，添加到结果集的尾部
		copy(res[i:], left[l:])
		copy(res[i+len(left)-l:], right[r:])
		return res
	}
	i := 1 //子序列大小初始1
	res := make([]int, 0)
	// i控制每次划分的序列长度
	for i < len(nums) {
		// j根据i值执行具体的合并
		j := 0
		// 按顺序两两合并，j用来定位起始点
		// 随着序列翻倍，每次两两合并的数组大小也翻倍
		for j < len(nums) {
			if j+2*i > len(nums) {
				res = merge(nums[j:j+i], nums[j+i:])
			} else {
				res = merge(nums[j:j+i], nums[j+i:j+2*i])
			}
			// 通过index控制每次将合并的数据填入nums中
			// 重填入的次数和合并及二叉树的高度相关
			index := j
			for _, v := range res {
				nums[index] = v
				index++
			}
			j = j + 2*i
		}
		i *= 2
	}
	return nums
}
```

### 快速排序

```go
func sortArray(nums []int) []int {
    // 快速排序，基于比较，不稳定算法，时间平均O(nlogn)，最坏O(n^2)，空间O(logn)
	// 分治思想，选主元，依次将剩余元素的小于主元放其左侧，大的放右侧
	// 然后取主元的前半部分和后半部分进行同样处理，直至各子序列剩余一个元素结束，排序完成
	// 注意：
	// 小规模数据(n<100)，由于快排用到递归，性能不如插排
	// 进行排序时，可定义阈值，小规模数据用插排，往后用快排
	// golang的sort包用到了快排
	// (小数，主元，大数)
	var quick func(nums []int, left, right int) []int
	quick = func(nums []int, left, right int) []int {
		// 递归终止条件
		if left > right {
			return nil
		}
		// 左右指针及主元
		i, j, pivot := left, right, nums[left]
		for i < j {
			// 寻找小于主元的右边元素
			for i < j && nums[j] >= pivot {
				j--
			}
			// 寻找大于主元的左边元素
			for i < j && nums[i] <= pivot {
				i++
			}
			// 交换i/j下标元素
			nums[i], nums[j] = nums[j], nums[i]
		}
		// 交换元素
		nums[i], nums[left] = nums[left], nums[i]
		quick(nums, left, i-1)
		quick(nums, i+1, right)
		return nums
	}
	return quick(nums, 0, len(nums)-1)
}
```

### 堆排序

```go
func sortArray(nums []int) []int {
    // 堆排序-大根堆，升序排序，基于比较交换的不稳定算法，时间O(nlogn)，空间O(1)-迭代建堆
	// 遍历元素时间O(n)，堆化时间O(logn)，开始建堆次数多些，后面次数少 
	// 主要思路：
	// 1.建堆，从非叶子节点开始依次堆化，注意逆序，从下往上堆化
	// 建堆流程：父节点与子节点比较，子节点大则交换父子节点，父节点索引更新为子节点，循环操作
	// 2.尾部遍历操作，弹出元素，再次堆化
	// 弹出元素排序流程：从最后节点开始，交换头尾元素，由于弹出，end--，再次对剩余数组元素建堆，循环操作
	// 建堆函数，堆化
	var heapify func(nums []int, root, end int)
	heapify = func(nums []int, root, end int) {
		// 大顶堆堆化，堆顶值小一直下沉
		for {
			// 左孩子节点索引
			child := root*2 + 1
			// 越界跳出
			if child > end {
				return
			}
			// 比较左右孩子，取大值，否则child不用++
			if child < end && nums[child] <= nums[child+1] {
				child++
			}
			// 如果父节点已经大于左右孩子大值，已堆化
			if nums[root] > nums[child] {
				return
			}
			// 孩子节点大值上冒
			nums[root], nums[child] = nums[child], nums[root]
			// 更新父节点到子节点，继续往下比较，不断下沉
			root = child
		}
	}
	end := len(nums)-1
	// 从最后一个非叶子节点开始堆化
	for i:=end/2;i>=0;i-- {
		heapify(nums, i, end)
	}
	// 依次弹出元素，然后再堆化，相当于依次把最大值放入尾部
	for i:=end;i>=0;i-- {
		nums[0], nums[i] = nums[i], nums[0]
		end--
		heapify(nums, 0, end)
	}
	return nums
}
```

### 基数排序

```go
func radix_sort(li []int) {
    // 先以个位数的⼤小来对数据进⾏排序，接着以十位数的⼤小来对数据进⾏排序，接着以百位数的⼤小......
    // 排到最后，就是一组有序的元素了。不过，他在以某位数进行排序的时候，是⽤用“桶”来排序的。
    // 由于某位数(个位/⼗位....，不是整个数)的⼤小范围为0-9，所以我们需要10个桶，
    // 然后把具有相同 数值的数放进同⼀个桶⾥，之后再把桶里的数按照0号桶到9号桶的顺序取出来，
    // 这样一趟下来，按照某位数的排序就完成了。
    // 算法效率：时间复杂度: O(kn)，空间复杂度: O(n+k)，稳定

	// 一次遍历获取最大值
    max_num := li[0]
    for i := 0; i < len(li); i++ {
        if max_num < li[i] {
            max_num = li[i]
        }
    }
	// 根据最大值的位数确定分几轮基数排序，如234，需要3轮，9仅需要一轮排序
    for j := 0; j < len(strconv.Itoa(max_num)); j++ {
		// 1.每轮排序，先分桶，数据装桶
        bin := make([][]int, 10)
        for k := 0; k < len(li); k++ {
            n := li[k] / int(math.Pow(10, float64(j))) % 10
            bin[n] = append(bin[n], li[k])
        }
		// 2.每轮排序，装完桶后，依次遍历桶，重排数组
        m := 0
        for p := 0; p < len(bin); p++ {
            for q := 0; q < len(bin[p]); q++ {
                li[m] = bin[p][q]
                m++
            }
        }
    }
}
```

### 桶排序

```go
func sortArray(nums []int) []int {
    // 桶排序，基于哈希思想的外排稳定算法，空间换时间，时间O(n+k)
	// 相当于计数排序的改进版，服从均匀分布，先将数据分到有限数量的桶中，
	// 每个桶分别排序，最后将非空桶的数据拼接起来
	var bucket func(nums []int, bucketSize int) []int
	bucket = func(nums []int, bucketSize int) []int {
		if len(nums) < 2 {
			return nums
		}
		// 获取最大最小值
		minAndMax := func(nums []int) (min, max int) {
			minNum := math.MaxInt32
			maxNum := math.MinInt32
			for i:=0;i<len(nums);i++ {
				if nums[i] < minNum {
					minNum = nums[i]
				}
				if nums[i] > maxNum {
					maxNum = nums[i]
				}
			}
			return minNum, maxNum
		}
		min_, max_ := minAndMax(nums)
		// 定义桶
		// 构建计数桶
		bucketCount := (max_-min_)/bucketSize + 1
		buckets := make([][]int, bucketCount)
		for i:=0;i<bucketCount;i++ {
			buckets[i] = make([]int, 0)
		}
		// 装桶-排序过程
		for i:=0;i<len(nums);i++ {
			// 桶序号
			bucketNum := (nums[i]-min_) / bucketSize
			buckets[bucketNum] = append(buckets[bucketNum], nums[i])
		}
		// 桶中排序
		// 上述装桶完成，出桶填入元素组
		index := 0
		for _, bucket := range buckets {
			sort.Slice(bucket, func(i, j int) bool {
				return bucket[i] < bucket[j]
			})
			for _, num := range bucket {
				nums[index] = num
				index++
			}
		}
		return nums
	}
	// 定义桶中的数量
	var bucketSize int = 2
	return bucket(nums, bucketSize)
}
```

### 计数排序

```go
func sortArray(nums []int) []int {
    // 计数排序，基于哈希思想的稳定外排序算法，空间换时间，时间O(n)，空间O(n)
	// 数据量大时，空间占用大
	// 空间换时间，通过开辟额外数据空间存储索引号记录数组的值和数组额个数
	// 思路：
	// 1.找出待排序的数组的最大值和最小值
	// 2.创建数组存放各元素的出现次数，先于[min, max]之间
	// 3.统计数组值的个数
	// 4.反向填充数组，填充时注意,num[i]=j+min，
	// j-前面需要略过的数的个数，两个维度，依次递增的数j++，一个是重复的数的计数j-不变
	if len(nums) == 0 {
		return nums
	}
	// 获取最大最小值
	minAndMax := func(nums []int) (min,max int) {
		minNum := math.MaxInt32
		maxNum := math.MinInt32
		for i:=0;i<len(nums);i++ {
			if nums[i] < minNum {
				minNum = nums[i]
			}
			if nums[i] > maxNum {
				maxNum = nums[i]
			}
		}
		return minNum, maxNum
	}
	min_, max_ := minAndMax(nums)
	// 中转数组存放遍历元素
	// 空间只需要min-max
	tmpNums := make([]int, max_-min_+1)
	// 遍历原数组
	for i:=0;i<len(nums);i++ {
		tmpNums[nums[i]-min_]++
	}
	// 遍历中转数组填入原数组
	j := 0
	for i:=0;i<len(nums);i++ {
		// 如果对应数字cnt=0，说明可以计入下一位数字
		for tmpNums[j] == 0 {
			j++
		}
		// 填入数字
		nums[i] = j + min_
		// 填一个数字，对应数字cnt--
		tmpNums[j]--
	}
	return nums
}
```

## 二叉树

### 二叉搜索树 BST

定义：
1. 对于 BST 的每一个节点 node，左子树节点的值都比 node 的值要小，右子树节点的值都比 node 的值大。
2. 对于 BST 的每一个节点 node，它的左侧子树和右侧子树都是 BST。

定义一个二叉树节点：
```go
type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}
```

#### 验证二叉树是否是二叉搜索树
```go
func isValidBST(root *TreeNode) bool {
	return traverse(root, nil, nil)
}

func traverse(root, min, max *TreeNode) bool {
	if root == nil {
		return true
	}
	if min != nil && root.Val <= min.Val {
		return false
	}
	if max != nil && root.Val >= max.Val {
		return false
	}
	return traverse(root.Left, min, root) && traverse(root.Right, root, max)
}
```

#### 搜索值
```go
func searchBST(root *TreeNode, val int) *TreeNode {
	if root == nil {
		return nil
	}
	if root.Val == val {
		return root
	} else if root.Val > val {
		return searchBST(root.Left, val)
	} else {
		return searchBST(root.Right, val)
	}
}
```

#### 插入节点
```go
func insertIntoBST(root *TreeNode, val int) *TreeNode {
	if root == nil {
		return &TreeNode{val, nil, nil}
	}
	if root.Val > val {
		root.Left = insertIntoBST(root.Left, val)
	}
	if root.Val < val {
		root.Right = insertIntoBST(root.Right, val)
	}
	return root
}
```

#### 删除节点
```go
func deleteNode(root *TreeNode, key int) *TreeNode {
	if root == nil {
		return nil
	}
	if root.Val == key {
		// found it and delete
		// 左右子树为空，则直接用右左子树替换此节点
		if root.Left == nil {
			return root.Right
		}
		if root.Right == nil {
			return root.Left
		}
		// 左右子树都有节点，则将右子树最小值替换此节点(也可以用左子树最大值替换此节点，选一种实现即可)
		rightMin := findRightMinInBST(root.Right)
		// 删除rightMin节点
		root.Right = deleteNode(root.Right, rightMin.Val)
		// 再替换rightMin与root
		rightMin.Left = root.Left
		rightMin.Right = root.Right
		root = rightMin
	} else if root.Val > key {
		root.Left = deleteNode(root.Left, key)
	} else {
		root.Right = deleteNode(root.Right, key)
	}
	return root
}

func findRightMinInBST(root *TreeNode) *TreeNode {
	for root.Left != nil {
		root = root.Left
	}
	return root
}
```

## 动态规划

动态规划解题套路框架:

明确 base case -> 明确「状态」 -> 明确「选择」 -> 定义 dp 数组/函数的含义。

基本思路:
1. 确定 base case。
2. 确定「状态」，也就是原问题和子问题中会变化的变量。
3. 确定「选择」，也就是导致「状态」产生变化的行为。
4. 明确 dp 函数/数组的定义。

实现：
- 自顶向下的带备忘录的递归解法
- 自底向上的dp table递推解法

优化：
- 自顶向下，时间优化，观察状态偏移是否存在重复值，增加备忘录
- 自底向上，空间优化，关注dp数组递推关系，是否存在某些状态不变，进行降维

[四键键盘](https://labuladong.github.io/algo/3/28/94/)


### 背包问题

#### 0-1 背包问题

给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？

```
输入：N = 3, W = 4, wt = [2, 1, 3], val = [4, 2, 3]

输出：6
解释：选择前两件物品装进背包，总重量 3 小于 W，可以获得最大价值 6
```

思路：
```
// dp[i][w] 的定义: 对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]
int[][] dp[N+1][W+1]
dp[0][..] = 0
dp[..][0] = 0

for i in [1..N]:
    for w in [1..W]:
        dp[i][w] = max(
            把物品 i 装进背包,
            不把物品 i 装进背包
        )
return dp[N][W]
```

实现：
```go
func knapsack(n, w int, wt []int, val []int) int {
	dp := make([][]int, n+1)
	for i := range dp {
		dp[i] = make([]int, w+1)
	}

	for i := 1; i <= n; i++ {
		for j := 1; j <= w; j++ {
			if j-wt[i-1] < 0 {
				// 背包容量不足，只能选择不装入背包
				dp[i][j] = dp[i-1][j]
			} else {
				dp[i][j] = maxInt(
					dp[i-1][j],                  // 不装入背包
					dp[i-1][j-wt[i-1]]+val[i-1], // 装入背包
				)
			}
		}
	}
	return dp[n][w]
}

func maxInt(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

#### 完全背包问题

有一个背包，最大容量为 amount，有一系列物品 items，每个物品的重量为 items[i]，每个物品的数量无限。请问有多少种方法，能够把背包恰好装满？

思路：
```
// dp[i][j] 的定义：若只使用前 i 个物品（可以重复使用），当背包容量为 j 时，有 dp[i][j] 种方法可以装满背包
int dp[N+1][amount+1]
dp[0][..] = 0
dp[..][0] = 1

for i in [1..N]:
    for j in [1..amount]:
        把物品 i 装进背包,
        不把物品 i 装进背包
return dp[N][amount]
```

实现：
```go
func knapsack(amount int, items []int) int {
	n := len(items)
	// dp[i][j] 的定义：若只使用前 i 个物品（可以重复使用），当背包容量为 j 时，有 dp[i][j] 种方法可以装满背包
	dp := make([][]int, n+1)
	for i := range dp {
		dp[i] = make([]int, amount+1)
		dp[i][0] = 1
	}

	for i := 1; i <= n; i++ {
		for j := 1; j <= amount; j++ {
			if j-items[i-1] < 0 {
				// 容量不够
				dp[i][j] = dp[i-1][j]
			} else {
				// 不装入+装入的方法的和
				// 注意，完全背包可以装入重复的值，所以这里转入的方法，是dp[i][j-items[i-1]]
				dp[i][j] = dp[i-1][j] + dp[i][j-items[i-1]]
			}
		}
	}

	return dp[n][amount]
}
```

## 贪心

[会议室问题](https://labuladong.github.io/algo/3/29/100/)

## 回溯

框架：

```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

### N 皇后问题

给你一个 N×N 的棋盘，让你放置 N 个皇后，使得它们不能互相攻击。皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。

```c++
vector<vector<string>> res;

/* 输入棋盘边长 n，返回所有合法的放置 */
vector<vector<string>> solveNQueens(int n) {
    // vector<string> 代表一个棋盘
    // '.' 表示空，'Q' 表示皇后，初始化空棋盘
    vector<string> board(n, string(n, '.'));
    backtrack(board, 0);
    return res;
}

// 路径：board 中小于 row 的那些行都已经成功放置了皇后
// 选择列表：第 row 行的所有列都是放置皇后的选择
// 结束条件：row 超过 board 的最后一行
void backtrack(vector<string>& board, int row) {
    // 触发结束条件
    if (row == board.size()) {
        res.push_back(board);
        return;
    }
    
    int n = board[row].size();
    for (int col = 0; col < n; col++) {
        // 排除不合法选择
        if (!isValid(board, row, col)) {
            continue;
        }
        // 做选择
        board[row][col] = 'Q';
        // 进入下一行决策
        backtrack(board, row + 1);
        // 撤销选择
        board[row][col] = '.';
    }
}

/* 是否可以在 board[row][col] 放置皇后？ */
bool isValid(vector<string>& board, int row, int col) {
    int n = board.size();
    // 检查列是否有皇后互相冲突
    for (int i = 0; i <= row; i++) {
        if (board[i][col] == 'Q')
            return false;
    }
    // 检查右上方是否有皇后互相冲突
    for (int i = row - 1, j = col + 1; 
            i >= 0 && j < n; i--, j++) {
        if (board[i][j] == 'Q')
            return false;
    }
    // 检查左上方是否有皇后互相冲突
    for (int i = row - 1, j = col - 1;
            i >= 0 && j >= 0; i--, j--) {
        if (board[i][j] == 'Q')
            return false;
    }
    return true;
}
```

### 排列组合与子集

排列是一类问题，组合和子集是一类问题。

#### 元素无重不可复选

即 nums 中的元素都是唯一的，每个元素最多只能被使用一次，backtrack 核心代码如下：

```java
/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i + 1);
        // 撤销选择
        track.removeLast();
    }
}

/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 剪枝逻辑
        if (used[i]) {
            continue;
        }
        // 做选择
        used[i] = true;
        track.addLast(nums[i]);

        backtrack(nums);
        // 撤销选择
        track.removeLast();
        used[i] = false;
    }
}
```

#### 元素可重不可复选

即 nums 中的元素可以存在重复，每个元素最多只能被使用一次，其关键在于排序和剪枝，backtrack 核心代码如下：

```java
Arrays.sort(nums);
/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i < nums.length; i++) {
        // 剪枝逻辑，跳过值相同的相邻树枝
        if (i > start && nums[i] == nums[i - 1]) {
            continue;
        }
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i + 1);
        // 撤销选择
        track.removeLast();
    }
}


Arrays.sort(nums);
/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 剪枝逻辑
        if (used[i]) {
            continue;
        }
        // 剪枝逻辑，固定相同的元素在排列中的相对位置
        if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
            continue;
        }
        // 做选择
        used[i] = true;
        track.addLast(nums[i]);

        backtrack(nums);
        // 撤销选择
        track.removeLast();
        used[i] = false;
    }
}
```

#### 元素无重可复选

即 nums 中的元素都是唯一的，每个元素可以被使用若干次，只要删掉去重逻辑即可，backtrack 核心代码如下：

```java
/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i);
        // 撤销选择
        track.removeLast();
    }
}


/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        backtrack(nums);
        // 撤销选择
        track.removeLast();
    }
}
```

### 有限状态机与 KMP 字符匹配

KMP 算法是在 txt 中查找子串 pat，如果存在，返回这个子串的起始索引，否则返回 -1。

思路：
```
空间换时间，先依据pat构建dp数组，再对txt搜索。

pat串长度为m，匹配字符的个数有256个（ascii码）

dp[j][c] = next
0 <= j < m，代表当前的状态，即当前匹配到的pat串的字符索引
0 <= c < 256，代表遇到的字符（ASCII 码）
0 <= next <= M，代表下一个状态

比如，对于 pat = "ABABC"
dp[4]['A'] = 3 表示：
当前是状态 4，如果遇到字符 A，
pat 应该转移到状态 3

dp[1]['B'] = 2 表示：
当前是状态 1，如果遇到字符 B，
pat 应该转移到状态 2
```

实现：

```go
type kmp struct {
	dp  [][]int
	pat string
}

func construct(pat string) kmp {
	m, n := len(pat), 256 // 256个ascii码
	dp := make([][]int, m)
	for i := range dp {
		dp[i] = make([]int, n)
	}
	k := kmp{dp, pat}

	// base case
	dp[0][int(pat[0])] = 1
	// 影子状态初始为0
	x := 0
	for i := 1; i < m; i++ {
		// 遍历256个ascii码
		for j := 0; j < n; j++ {
			if int(pat[i]) == j {
				dp[i][j] = i + 1
			} else {
				dp[i][j] = dp[x][j]
			}
		}
		// 更新x为上一个与pat[i]有公共前缀的下标位置
		x = dp[x][int(pat[i])]
	}

	return k
}

func (k kmp) search(txt string) int {
	m, n := len(k.pat), len(txt)
	j := 0
	for i := 0; i < n; i++ {
		j = k.dp[j][int(txt[i])]
		if j == m {
			return i - j + 1
		}
	}
	return -1
}
```

## BFS

### 最短距离

从一个图中找到从起点 start 到终点 target 的最近距离。

算法框架：

```java
// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路
    
    q.offer(start); // 将起点加入队列
    visited.add(start);
    int step = 0; // 记录扩散的步数

    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            /* 划重点：这里判断是否到达终点 */
            if (cur is target)
                return step;
            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj()) {
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
            }
        }
        /* 划重点：更新步数在这里 */
        step++;
    }
}
```

## 数学公式

### 最大公约数

```
func gcd(x, y int) int {
	if y == 0 {
		return x
	}
	return gcd(y, x%y)
}
```

### 最小公倍数

```
func lcm(x, y int) int {
	return x * y / gcd(x, y)
}
```

## 系列问题

### 岛屿问题

二维数组 grid，其中只包含 0 或者 1，0 代表海水，1 代表陆地，且假设该矩阵四周都是被海水包围着的。连成片的陆地形成岛屿，计算这个矩阵 grid 中岛屿的个数。

dfs遍历+Flood Fill算法。遍历过程修改岛屿为海水，可以避免使用visited数组，节省空间。

```go
func numIslands(grid [][]byte) int {
	res := 0
	m, n := len(grid), len(grid[0])
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if grid[i][j] == '1' {
				res++
				dfs(grid, i, j)
			}
		}
	}
	return res
}

func dfs(grid [][]byte, row, col int) {
	m, n := len(grid), len(grid[0])
	if row >= m || row < 0 || col >= n || col < 0 {
		return
	}

	if grid[row][col] == '0' {
		return
	}

	grid[row][col] = '0'

	dfs(grid, row-1, col)
	dfs(grid, row+1, col)
	dfs(grid, row, col-1)
	dfs(grid, row, col+1)
}
```

### 股票问题

输入股票价格数组 prices，你最多进行 max_k 次交易，每次交易需要额外消耗 fee 的手续费，而且每次交易之后需要经过 cooldown 天的冷冻期才能进行下一次交易，请你计算并返回可以获得的最大利润。

```go
// dp[i][k][0 or 1]
// 0 <= i <= n-1, 1 <= k <= K
// n 为天数，K 为交易数的上限，0 和 1 代表是否持有股票
// 此问题共有 n*K*2 种状态

// base case：
// dp[-1][...][0] = dp[...][0][0] = 0
// dp[-1][...][1] = dp[...][0][1] = -infifity

// 状态转移
// dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
// dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
func maxProfit(prices []int, k, cooldown, fee int) int {
	n := len(prices)
	// 确定k的情况下，如果k>n/2，即无论如何都用不完k的额度，等于不限制k
	if k > n/2 {
		return maxProfitWithInfinityK(prices, cooldown, fee)
	}
	dp := make([][][]int, n)
	for i := range dp {
		dp[i] = make([][]int, k+1)
		for j := range dp[i] {
			dp[i][j] = make([]int, 2)
			dp[i][0][0] = 0
			dp[i][0][1] = math.MinInt
		}
	}

	for i := 0; i < n; i++ {
		for j := k; i > 0; j-- {
			// base case 1
			if i-1 == -1 {
				dp[i][j][0] = 0
				dp[i][j][1] = -prices[i] - fee
				continue
			}
			// base case 2
			if i-cooldown-1 < 0 {
				dp[i][j][0] = maxInt(dp[i-1][j][0], dp[i-1][j][1]+prices[i])
				dp[i][j][1] = maxInt(dp[i-1][j][1], -prices[i]-fee)
				continue
			}
			dp[i][j][0] = maxInt(dp[i-1][j][0], dp[i-1][j][1])
			// 同时考虑 cooldown 和 fee
			dp[i][j][1] = maxInt(dp[i-1][j][1], dp[i-cooldown-1][j-1][0]-prices[i]-fee)
		}
	}
	return dp[n-1][k][0]
}

func maxProfitWithInfinityK(prices []int, cooldown, fee int) int {
	// 相当于k正无穷，k和k-1相同
	n := len(prices)
	dp := make([][]int, n)
	for i := range dp {
		dp[i] = make([]int, 2)
	}
	for i := 0; i < n; i++ {
		// base case 1
		if i-1 == -1 {
			dp[i][0] = 0
			dp[i][1] = -prices[i] - fee
			continue
		}
		// base case 2
		if i-cooldown-1 < 0 {
			dp[i][0] = maxInt(dp[i-1][0], dp[i-1][1]+prices[i])
			dp[i][1] = maxInt(dp[i-1][1], -prices[i]-fee)
			continue
		}
		dp[i][0] = maxInt(dp[i-1][0], dp[i-1][1]+prices[i])
		// 同时考虑 cooldown 和 fee
		dp[i][1] = maxInt(dp[i-1][1], dp[i-cooldown-1][0]-prices[i]-fee)
	}
	return dp[n-1][0]
}

func maxInt(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```